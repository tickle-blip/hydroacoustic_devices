#pragma kernel MapBeamDistanceData
#pragma kernel MapBeamNoiseDistanceData
#pragma kernel FillWaterColumnStrip
#pragma kernel ComputeDetect
#pragma kernel FillSideScanStrip
#pragma kernel FillSnippetsStrip
#pragma kernel ClearBuffer
#pragma kernel ClearBeamBuffer
#include "../SonarsDistributionBase.cginc"
Texture2D<float4> Source;
RWTexture2D<float> Destination;
RWTexture2D<uint> DestinationUINT;

RWStructuredBuffer<float> DistanceBuffer;
//uint reflectivity

float4x4 _InvViewMatrix;
//
Texture2D<uint> Read_TexUint_1;
Texture2D<uint> Read_TexUint_2;
float Zoom_angle1, Zoom_angle2;
float Gain, TVG, NoiseWideness, NoisePatternScroll, BlindZoneRadius, HorisontalFOV,VerticalFOV;
float4 Noise12_Scale_Bias;
float Range;
float4 WorldPosRot;
float TopNoiseTreshold;
float BottomNoiseTreshold;

float Resolution;
//Flex Mode
float BeamCount;
float BeamCount_left, BeamCount_mid;
float LeftUVBorder, RightUVBorder;
float LeftBeamDensity,RightBeamDensity, InBeamDensity;
float FlexModeEnabled;


//Detect
int Wedge_MemoryAmount;
//Distance, Color, uv.x
RWStructuredBuffer<uint2> BeamBuffer;
RWStructuredBuffer<uint4> BeamHistoryBuffer;
RWStructuredBuffer<float3> PosBuffer;
void BilinearColorPixels(float2 uv, float color,float2 dim,float max,float gain)
{
	uv.y += 0.5;
	float2 y_min_max = float2(floor(uv.y) - 0.5, floor(uv.y) + 0.5);

	float uv_frac = 1-frac(uv.y);

	float2 uv1 = float2(uv.x, y_min_max.x);
	float2 uv2 = float2(uv.x, y_min_max.y);
	if (DistanceBuffer[uv1.x + uv1.y*dim.x] > gain*5 ) return;
	DistanceBuffer[uv1.x + uv1.y*dim.x] += uv_frac*color;
	DistanceBuffer[uv2.x + uv2.y*dim.x] += uv_frac*color;
	
	float val1 = clamp(DistanceBuffer[uv1.x + uv1.y*dim.x], 0, gain*5);
	float val2 = clamp(DistanceBuffer[uv2.x + uv2.y*dim.x], 0, gain*5);
	val1 =remap(0,max,0,gain*5, val1);
	val2 =remap(0,max,0,gain*5,val2);
	//DestinationUINT[uv1] = DistanceBuffer[uv1.x + uv1.y*dim.x];
	//DestinationUINT[uv2] = DistanceBuffer[uv2.x + uv2.y*dim.x];
	Destination[uv1] = val1 +val1 * 0.2* (2 * rand(uv1) - 1);
	Destination[uv2] = val2 +val1 * 0.2* (2 * rand(uv2) - 1);
}


void LinearColorPixels1(float2 uv, float color, float2 dim, float max, float gain)
{
	float val;// = (DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)]);
	val = DistanceBuffer[uv.x + uv.y*dim.x];
	if (val < max) {
		DistanceBuffer[uv.x + uv.y*dim.x] += color;
		Destination[uv] = (val + color)*(1 + 0.25*(2 * rand(GetNoiseUVrelativeToWorld(uv, WorldPosRot, 1, NoisePatternScroll)) - 1));
	}
	/*
	if (DistanceBuffer[uv.x + uv.y*dim.x] > max) return;
	DistanceBuffer[uv.x + uv.y*dim.x] += color;

	float val1 = clamp(DistanceBuffer[uv.x + uv.y*dim.x], 0, gain *100);
	val1 = remap(0, max, 0, gain * 5, val1);
	val1 = DistanceBuffer[uv.x + uv.y*dim.x];
	//DestinationUINT[uv] = val1 +val1 * 0.1* (2 * rand(uv) - 1);
	DestinationUINT[uv] = val1 *(1 + 0.05*(2 * rand(GetNoiseUVrelativeToWorld(uv, WorldPosRot, 1, NoisePatternScroll)) - 1));*/
}
/*
void LinearColorPixels(float2 uv, float color, float2 dim, uint m, float gain)
{

	//if (DistanceBuffer[uv.x + uv.y*dim.x] > max) return;
	//float val = BeamBuffer[uv.x + uv.y*dim.x];
	//BeamBuffer[uv.x + uv.y*dim.x] = max(val, m);
	//val = BeamBuffer[uv.x + uv.y*dim.x];
	//

	InterlockedMax(BeamBuffer[uv.x], m);
	//DestinationUINT[uv] = val1 +val1 * 0.1* (2 * rand(uv) - 1);
	//DestinationUINT[uv] = float(BeamBuffer[uv.x + uv.y*dim.x]) / 10000;// *(1 + 0.05*(2 * rand(GetNoiseUVrelativeToWorld(uv, WorldPosRot, 1, NoisePatternScroll)) - 1));
}
*/
void ColorBeam(float2 uv, float color, float2 dim, float max, float gain)
{

	if (DistanceBuffer[uv.x + uv.y*dim.x] < max) 
	{
	DistanceBuffer[uv.x + uv.y*dim.x] += color;

	float val1 = DistanceBuffer[uv.x + uv.y*dim.x];
	Destination[uv] = val1;// +val1 * 0.1* (2 * rand(uv) - 1);
//	DestinationUINT[uv] = val1 * (1 + 0.05*(2 * rand(GetNoiseUVrelativeToWorld(uv, WorldPosRot, 1, NoisePatternScroll)) - 1));
	}
}





[numthreads(1024, 1, 1)]
void ClearBuffer(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	DistanceBuffer[id.x] = 0;
}





[numthreads(512, 1, 1)]
void ClearBeamBuffer(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	uint maxUint = 0xffffffff;
	BeamBuffer[id.x] = uint2(maxUint,0);
}


//DistanceTexture width is fixed = 512
//NumGroups(BeamCount,1,1)
[numthreads(1, 32, 1)]
void MapBeamNoiseDistanceData(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{


	//Distance Texture
	float4 s_dim;
	s_dim = GetDimensionsFrom(Source);

	//BeamTexture. width= num_beams, height = 512
	float4 d_dim;
	DestinationUINT.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	float beam_num = id.x;

	float leftZone = step(beam_num, BeamCount_left);
	float midZone = step(BeamCount_left, beam_num)*step(beam_num, (BeamCount_left + BeamCount_mid));
	float rightZone = step((BeamCount_left + BeamCount_mid), beam_num);

	float B_density = rightZone*RightBeamDensity + leftZone*LeftBeamDensity + midZone * InBeamDensity;
	B_density = FlexModeEnabled * B_density;

	float startUV = midZone * LeftUVBorder + rightZone * RightUVBorder;
	startUV = FlexModeEnabled * startUV;

	float flexX = (0.5 + leftZone * (beam_num)+midZone * (beam_num - BeamCount_left) + rightZone * (beam_num - (BeamCount_left + BeamCount_mid)))*s_dim.x;
	flexX = ((flexX)*B_density + startUV);

	float coordX = (flexX *FlexModeEnabled + (1 - FlexModeEnabled)*id.x*d_dim.x);
	//coordX = id.x*d_dim.x;
	//TOUGH Correction
	coordX = PaniniYfromX(coordX,HorisontalFOV);

	coordX *= s_dim.z;

	int NumOfSamples = int(s_dim.z / d_dim.z);

	float2 dx = float2(1, 0);
	float2 dest_uv = id.xy*d_dim.xy*s_dim.zw;
	dest_uv.x = coordX;
	dest_uv.y = id.y;

	float ran = rand(id.xy);
	float2 sample_uv;
	float2 distance_Samples[8];
	float2 noise_Samples[8];


	Gain = 0.25 + Gain*0.75;
	float oRefl;
	for (int i = 0; i < NumOfSamples; i++) 
	{
		sample_uv = dest_uv + dx * i;



		float sc = lerp(1, 2, 1 - (Range - 2) / 300);
		float2 n1_uv_sample = GetNoiseUVrelativeToWorld(sample_uv*s_dim.xy, WorldPosRot, 1, NoisePatternScroll);
		float2 n2_uv_sample = GetNoiseUVrelativeToWorld(sample_uv*s_dim.xy, WorldPosRot + float4(10, 5, 15, 20), 1, NoisePatternScroll);

		float n1_radius, n2_radius;

		n1_radius = smoothNoise((n1_uv_sample*Noise12_Scale_Bias.x));

		n2_radius = warpedNoise((float2(frac(n2_uv_sample + 0.5))*Noise12_Scale_Bias.y), WorldPosRot);
		n2_radius = remap(0, 1, 0.2, 0.8, n2_radius);
		n1_radius *= (1 + (NoiseWideness / 1 * (2 * ran - 1)*0.1));
		//n2_radius *= (1 + NoiseWideness / 5 * (2 * ran - 1)*0.1);
		n1_radius = bias(n1_radius, Noise12_Scale_Bias.z);
		n2_radius = bias(n2_radius, Noise12_Scale_Bias.w);

		oRefl = max(0.1, Gain);
		
		float flag = step(ran, 0.5);
		float r = lerp(n1_radius, n2_radius, flag);
		distance_Samples[i] = float2(r, oRefl*rand(id.yy));
		//distance_Samples[i] = 0;
		noise_Samples[i] = float2(Source[sample_uv].x*(1 + 0.00*(2 * smoothNoise(dest_uv) - 1)), Source[sample_uv].y);
		
	}
	//Fill Beam Texture
	for (int i = 0; i < NumOfSamples; i++) {

		float t, refl,val,val_m;

		//val = val_m = (DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)]);
		oRefl = noise_Samples[i].y;
		t = 1 - noise_Samples[i].x;
		//t = remap(0.5, 1, 0, 1, t);
		refl = clamp(oRefl*lerp(0., 1, t) + lerp(0, TVG, noise_Samples[i].x) / 10, 0, oRefl);

		//if (val_m < refl) {
		//	DestinationUINT[float2(id.x, (noise_Samples[i].x)*d_dim.w)] = (val_m + (Gain*refl));
		//}
		//ColorBeam(float2(id.x, (noise_Samples[i].x)*d_dim.w), Gain*refl, d_dim.zw, refl, Gain);

		
		oRefl = distance_Samples[i].y;
		 t = 1-distance_Samples[i].x;
		//t = remap(0.5, 1, 0, 1, t);
		 refl = clamp(oRefl*lerp(0., 1, t) + lerp(0, TVG, distance_Samples[i].x) / 10, 0, oRefl);
		 float max_refl = uint(refl * 10000);
		 uint val_to_add = uint((Gain * refl) * 10000);

		 float2 coord = float2(id.x, (distance_Samples[i].x)*d_dim.w);

		 InterlockedAdd(DestinationUINT[coord], val_to_add );
		 InterlockedMin(DestinationUINT[coord], max_refl);
		 //InterlockedAdd(DestinationUINT[coord], val_to_add);


		/* if (val < refl) {	
			 //DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)] = (val + (Gain*Gain*refl));
			 DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)] = float4((val + (Gain*refl)), id.y*s_dim.y,0,1);
		 }*/
		//ColorBeam(float2(id.x, (distance_Samples[i].x)*d_dim.w), Gain*Gain*refl, d_dim.zw, refl, Gain);

		

	}
}


//DistanceTexture width is fixed = 512
//NumGroups(BeamCount,1,1)
[numthreads(1, 32, 1)]
void MapBeamDistanceData(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{

	//Distance Texture
	float4 s_dim;
	s_dim = GetDimensionsFrom(Source);

	//BeamTexture. width= num_beams, height = 512
	float4 d_dim;
	DestinationUINT.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	float beam_num = id.x+1;

	float leftZone = step(beam_num, BeamCount_left);
	float midZone = step(BeamCount_left, beam_num-1)*step(beam_num, (BeamCount_left + BeamCount_mid));
	float rightZone = step((BeamCount_left + BeamCount_mid), beam_num-1);

	float B_density = rightZone*RightBeamDensity + leftZone*LeftBeamDensity + midZone * InBeamDensity;
	B_density = FlexModeEnabled * B_density;

	float startUV = midZone * LeftUVBorder + rightZone * RightUVBorder;
	startUV = FlexModeEnabled * startUV;

	float flexX = (leftZone * (beam_num)+midZone * (beam_num - BeamCount_left) + rightZone * (beam_num - (BeamCount_left + BeamCount_mid))-1)*s_dim.x;
	flexX = ((flexX)*B_density + startUV);

	float coordX = (flexX *FlexModeEnabled + (1 - FlexModeEnabled)*id.x*d_dim.x);
	//coordX = id.x*d_dim.x;
	//TOUGH Correction
	coordX = PaniniYfromX(coordX, HorisontalFOV);
	
	coordX *= s_dim.z;
	//coordX -= 0.5;
	int NumOfSamples = int(s_dim.z / d_dim.z);

	float2 dx = float2(1, 0);
	float2 dest_uv = id.xy*d_dim.xy*s_dim.zw;
	dest_uv.x = coordX;
	dest_uv.y = id.y;



	float2 sample_uv;
	float2 distance_Samples[8];
	for (int i = 0; i < NumOfSamples; i++)
	{
		sample_uv = dest_uv + dx * i;
		distance_Samples[i] = float2(Source[sample_uv].x*(1 + 0.003*(2 * smoothNoise(dest_uv) - 1)), Source[sample_uv].y);
	}
	//Fill Beam Texture
	Gain = 0.5 + Gain*0.5;
	float max_r=0;
	float2 coord;
	for (int i = 0; i < NumOfSamples; i++) {
		float oRefl = distance_Samples[i].y;
		float t = 1 - distance_Samples[i].x;
		//t = remap(0.5, 1, 0, 1, t);
		float refl = clamp(oRefl*lerp(0, 1, t) + lerp(0, TVG, distance_Samples[i].x) / 10, 0, oRefl);

		float flag = step(max_r, refl);
		max_r = max(max_r, refl);
		uint val_to_add = uint((Gain * refl)*10000);
		uint max_refl = uint(refl * 10000);
		coord =coord*(1-flag) + (flag)* float2(id.x, (distance_Samples[i].x)*d_dim.w);

		float val = float(DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)])/10000;
		
		if (val < refl) {
			//InterlockedAdd(DestinationUINT[coord], val_to_add/ NumOfSamples);
//			DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)] = uint(val*10000)+val_to_add;
			//InterlockedMin(DestinationUINT[coord], max_refl);

		}
		
		/*float val = DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)];
		//if (val > refl) return;
		//DestinationUINT[float2(id.x, (distance_Samples[i].x)*BeamCount)] = (val + (Gain*refl))*step(0,t);
		//val = (DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)]);
		if (val < refl) {
			DestinationUINT[float2(id.x, (distance_Samples[i].x)*d_dim.w)] = float4((val + (Gain*refl)),id.y*s_dim.y,0,1);
		}*/
		//ColorBeam(float2(id.x, (distance_Samples[i].x)*d_dim.w), Gain*refl, d_dim.zw, refl, Gain);
	}
	InterlockedAdd(DestinationUINT[coord], uint(10*(Gain*max_r/NumOfSamples/4) * 10000));
	InterlockedMin(DestinationUINT[coord], uint(10000*max_r));

}


int WC_BeamNumber;
[numthreads(64, 1, 1)]
void FillWaterColumnStrip(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	float4 s_dim;
	s_dim = GetDimensionsFrom(Source);
	float4 st_dim;
	DestinationUINT.GetDimensions(st_dim.z, st_dim.w);
	st_dim.xy = 1 / st_dim.zw;
	//y - radius
	//x - angle

	float a_data = float(Read_TexUint_1[float2(WC_BeamNumber, id.x)]) / 10000;
	float b_data = float(Read_TexUint_2[float2(WC_BeamNumber, id.x)]) / 10000;

	float a_data_left = float(Read_TexUint_1[float2(WC_BeamNumber, id.x - 1)]) / 10000;
	float b_data_left = float(Read_TexUint_2[float2(WC_BeamNumber, id.x - 1)]) / 10000;


	float a_data_right = float(Read_TexUint_1[float2(WC_BeamNumber, id.x + 1)]) / 10000;
	float b_data_right = float(Read_TexUint_2[float2(WC_BeamNumber, id.x + 1)]) / 10000;

	float DistanceStrip = max(a_data, b_data);

	float DistanceStrip_left = max(a_data_left, b_data_left);
	float DistanceStrip_right = max(a_data_right, b_data_right);
	float2 uv = id.xy*s_dim.xy;
	Destination[float2(0, id.x)] = max(DistanceStrip, max(DistanceStrip_left, DistanceStrip_right));
	Destination[float2(0, id.x)] = DistanceStrip;
}

float SampleLinearY(Texture2D tex, float2 uv, float4 texelSize,float uv_frac) {

	float2 uv_texels = uv * texelSize.zw;// +float2(0.5, 0);
	float2 x_min_max = float2(floor(uv_texels.x)-0.5, floor(uv_texels.x) +0.5);
	//uv_frac = frac(uv_texels.y);

	float2 uv1 = float2(x_min_max.x, uv_texels.y);
	float2 uv2 = float2(x_min_max.y, uv_texels.y);

	float4 colorA = tex[uv1];
	float4 colorB = tex[uv2];
	return lerp(colorA, colorB, uv_frac).r;
}



[numthreads(16, 16, 1)]
void FillSideScanStrip(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	float4 s_dim;
	s_dim = GetDimensionsFrom(Source);
	float4 st_dim;
	Destination.GetDimensions(st_dim.z, st_dim.w);
	st_dim.xy = 1 / st_dim.zw;
	//y - radius
	//x - angle
	float2 uv = id.xy*s_dim.xy;
	//uv.x = 1 - uv.x;
	float2 DRWB = Source[id.xy];
	
	//uv = uv - 0.5;
	float a = step(0.5, uv.x);
	//SideScan. писать в нулевой столбик или 1?
	float angle = abs(uv.x - 0.5) * 2;
	float cosa = sin(angle*HorisontalFOV / 2 / 57.34);

	float tex_radius = DRWB.x *(1 + 0.01*rand(id.xy));

	float r; float n_Refl;
	//Noise
	{
		float sc = lerp(1, 2, 1 - (Range - 2) / 300);
		float2 n1_uv_sample = GetNoiseUVrelativeToWorld(uv, WorldPosRot, 1, NoisePatternScroll);
		float2 n2_uv_sample = GetNoiseUVrelativeToWorld(uv, float4(-1, 1, 1, 1)*WorldPosRot + float4(10, 5, 15, 20), 1, NoisePatternScroll);

		float n1_radius, n2_radius;

		n1_radius = smoothNoise((n1_uv_sample*Noise12_Scale_Bias.x));

		n2_radius = warpedNoise((float2(frac(n2_uv_sample + 0.5))*Noise12_Scale_Bias.y), WorldPosRot);
		n2_radius = remap(0, 1, 0.2, 0.8, n2_radius);
		n1_radius *= (1 + (NoiseWideness / 1 * (2 * rand(id.xy) - 1)*0.1));
		//n2_radius *= (1 + NoiseWideness / 5 * (2 * ran - 1)*0.1);
		n1_radius = bias(n1_radius, Noise12_Scale_Bias.z);
		n2_radius = bias(n2_radius, Noise12_Scale_Bias.w);

		n_Refl = max(0.1, Gain)*rand(id.yy);

		float noise_flag = step(rand(id.xy+100), 0.5);
		r = lerp(n1_radius, n2_radius, noise_flag);
	}

	float tex_flag = step(rand(id.xy + 199), 0.5);

	float radius = lerp(r, tex_radius, tex_flag);
	float oRefl = lerp(n_Refl, DRWB.y, tex_flag);
	

	//radius = uv.y;
	//float2 SS_uv = float2(lerp((1 - radius * cosa) / 2, (1 + radius * cosa) / 2, a), 0);
	float2 SS_uv = float2(lerp((1 - radius) / 2, (1 + radius ) / 2, a), 0);
	//SS_uv.x =radius;
	SS_uv.y = 0;
	//SS_coord = float2(0.5 + uv.y, 0)*st_dim.zw;
	//DestinationUINT[SS_coord] = max(DestinationUINT[SS_coord], DistVal);
	//DestinationUINT[SS_coord] = DistVal;
	//Snippets. писать в нулевой столбик или 1?

	//DestinationUINT_1[SN_coord] = max(DestinationUINT_1[SN_coord], DistVal);
	

	// *(1 + remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440))*remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440)));


	float t = (1 - radius);
	//t = remap(0.5, 1, 0, 1, t);
	
	//
	float reflectivity = clamp(oRefl*lerp(0., 1, t) + lerp(0, TVG, radius) / 10, 0, oRefl);
	
	float leftZone = step(uv.x, LeftUVBorder);
	float midZone = step(LeftUVBorder, uv.x)*step(uv.x, RightUVBorder);
	float rightZone = step(RightUVBorder, uv.x);
	
	float BeamDensity = BeamCount_mid / BeamCount;
	//Account of FlexMode
	reflectivity *= (leftZone*(1 - BeamDensity + (BeamDensity)*smoothstep(1, -0.0, (LeftUVBorder - uv.x) / LeftUVBorder))
			+ rightZone* (1 - BeamDensity + (BeamDensity)*smoothstep(1, -0.0, (uv.x - RightUVBorder) / (1 - RightUVBorder)))
		+ midZone)*FlexModeEnabled+(1- FlexModeEnabled);
	
	float gain = (0.25 + Gain * 0.75);
	gain = lerp(gain*gain, gain, tex_flag)*reflectivity;
	LinearColorPixels1(SS_uv*st_dim.zw,  gain, st_dim.zw, reflectivity, Gain);
}


[numthreads(16, 16, 1)]
void FillSnippetsStrip(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	float4 s_dim;
	s_dim = GetDimensionsFrom(Source);
	float4 st_dim;
	Destination.GetDimensions(st_dim.z, st_dim.w);
	st_dim.xy = 1 / st_dim.zw;
	//y - radius
	//x - angle
	float2 uv = id.xy*s_dim.xy;
	//uv.x = 1 - uv.x;
	float2 DRWB = Source[id.xy];

	//uv = uv - 0.5;
	float a = step(0.5, uv.x);
	//SideScan. писать в нулевой столбик или 1?
	float angle = abs(uv.x - 0.5) * 2;
	float cosa = sin(angle*HorisontalFOV / 2 / 57.34);

	float tex_radius = DRWB.x *(1 + 0.01*rand(id.xy));

	float r; float n_Refl;
	//Noise
	{
		float sc = lerp(1, 2, 1 - (Range - 2) / 300);
		float2 n1_uv_sample = GetNoiseUVrelativeToWorld(uv, WorldPosRot, 1, NoisePatternScroll);
		float2 n2_uv_sample = GetNoiseUVrelativeToWorld(uv, float4(-1, 1, 1, 1)*WorldPosRot + float4(10, 5, 15, 20), 1, NoisePatternScroll);

		float n1_radius, n2_radius;

		n1_radius = smoothNoise((n1_uv_sample*Noise12_Scale_Bias.x));

		n2_radius = warpedNoise((float2(frac(n2_uv_sample + 0.5))*Noise12_Scale_Bias.y), WorldPosRot);
		n2_radius = remap(0, 1, 0.2, 0.8, n2_radius);
		n1_radius *= (1 + (NoiseWideness / 1 * (2 * rand(id.xy) - 1)*0.1));
		//n2_radius *= (1 + NoiseWideness / 5 * (2 * ran - 1)*0.1);
		n1_radius = bias(n1_radius, Noise12_Scale_Bias.z);
		n2_radius = bias(n2_radius, Noise12_Scale_Bias.w);

		n_Refl = max(0.1, Gain)*rand(id.yy);

		float noise_flag = step(rand(id.xy + 100), 0.5);
		r = lerp(n1_radius, n2_radius, noise_flag);
	}

	float tex_flag = step(rand(id.xy + 199), 0.5);

	float radius = lerp(r, tex_radius, tex_flag);
	float oRefl = lerp(n_Refl, DRWB.y, tex_flag);


	//radius = uv.y;
	float2 SS_uv = float2(lerp((1 - radius * cosa) / 2, (1 + radius * cosa) / 2, a), 0);
	//float2 SS_uv = float2(lerp((1 - radius) / 2, (1 + radius ) / 2, a), 0);
	//SS_uv.x =radius;
	SS_uv.y = 0;
	//SS_coord = float2(0.5 + uv.y, 0)*st_dim.zw;
	//DestinationUINT[SS_coord] = max(DestinationUINT[SS_coord], DistVal);
	//DestinationUINT[SS_coord] = DistVal;
	//Snippets. писать в нулевой столбик или 1?

	//DestinationUINT_1[SN_coord] = max(DestinationUINT_1[SN_coord], DistVal);
	

	// *(1 + remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440))*remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440)));


	float t = (1 - radius);
	//t = remap(0.5, 1, 0, 1, t);


	float reflectivity = clamp(oRefl*lerp(0., 1, t) + lerp(0, TVG, radius) / 10, 0, oRefl);

	float leftZone = step(uv.x, LeftUVBorder);
	float midZone = step(LeftUVBorder, uv.x)*step(uv.x, RightUVBorder);
	float rightZone = step(RightUVBorder, uv.x);

	float BeamDensity = BeamCount_mid / BeamCount;
	//Account of FlexMode
	reflectivity *= (leftZone*(1 - BeamDensity + (BeamDensity)*smoothstep(1, -0.0, (LeftUVBorder - uv.x) / LeftUVBorder))
		+ rightZone * (1 - BeamDensity + (BeamDensity)*smoothstep(1, -0.0, (uv.x - RightUVBorder) / (1 - RightUVBorder)))
		+ midZone)*FlexModeEnabled + (1 - FlexModeEnabled);

	float gain = (0.25 + Gain * 0.75);
	gain = lerp(gain*gain, gain, tex_flag)*reflectivity;
	LinearColorPixels1(SS_uv*st_dim.zw, gain, st_dim.zw, reflectivity, Gain);
}




float MinDetectRange, MaxDetectRange;
int PingNumber;
[numthreads(64, 1, 1)]
void ComputeDetect(uint3 groupID : SV_GroupID,
	// 3D ID of thread group; range depends on Dispatch call
	uint3 groupThreadID : SV_GroupThreadID,
	// 3D ID of thread in a thread group; range depends on numthreads
	uint groupIndex : SV_GroupIndex,
	// flattened/linearized SV_GroupThreadID. 
	// groupIndex specifies the index within the group (0 to 63)
	uint3 id : SV_DispatchThreadID)
	// = SV_GroupID * numthreads + SV_GroupThreadID
	// id.x specifies the row in the input texture image
{
	float4 s_dim;
	Read_TexUint_1.GetDimensions(s_dim.z, s_dim.w);
	s_dim.xy = 1 / s_dim.zw;
	//Read_TexUint_1.GetDimensions(a.x, a.y);
	int raw;



	float beam_num = id.x + 1;

	float leftZone = step(beam_num, BeamCount_left);
	float midZone = step(BeamCount_left, beam_num - 1)*step(beam_num , (BeamCount_left + BeamCount_mid));
	float rightZone = step((BeamCount_left + BeamCount_mid), beam_num);

	float B_density = rightZone*RightBeamDensity + leftZone*LeftBeamDensity + midZone * InBeamDensity;
	B_density = FlexModeEnabled * B_density;

	float startUV = midZone * LeftUVBorder + rightZone * RightUVBorder;

	float flexX = (leftZone * (beam_num)+midZone * (beam_num - BeamCount_left) + rightZone * (beam_num - (BeamCount_left + BeamCount_mid)) - 1)/Resolution;
	flexX = ((flexX)*B_density + startUV);


	float coordX = (flexX *FlexModeEnabled + (1 - FlexModeEnabled)*beam_num / BeamCount);

	float aHor = (-0.5 + coordX) *HorisontalFOV*0.0174533;

	// find the maximum reflectivity of this Beam 
	BeamBuffer[id.x].x = 0;
	BeamBuffer[id.x].y = 0;
	float2 dist_uv_y;
	//int2 min_max_Raw = float2(MinDetectRange,MaxDetectRange) * s_dim.w;
	for (raw = 0; raw < s_dim.w; raw++)
	{

		uint s = (uint)(Read_TexUint_1[uint2(id.x, raw)]);
		uint n = (uint)(Read_TexUint_2[uint2(id.x, raw)]);
		//
		uint2 val = step(s.x, n.x)*n + step(n.x, s.x)*s;

		float d = cos(aHor)*float(raw*s_dim.y)*Range;
		val = val * step(d, MaxDetectRange)* step(MinDetectRange, d);
		//uint color = (uint)(1023.0 *Source[uint2(id.x,raw)].x);
		//color = max(color,(uint)(1023.0 *Noise1[uint2(id.x, raw)].x));
		
		if (val.x > BeamBuffer[id.x].y)
		{
			dist_uv_y = float2(raw / s_dim.w, float(val.y)/1023.);
			BeamBuffer[id.x].x = raw;
			BeamBuffer[id.x].y = val.x;
		}
	}
	





	///


	//coordX = id.x / BeamCount;
	float3 uv = float3(coordX, dist_uv_y.x, dist_uv_y.y); //uv.x - angleHOR, uv.y - distance, uv.z - angleVER
	 //in rad
	float aVer = (-0.5+uv.z) *VerticalFOV*0.0174533; //in rad
	//
	float r = uv.y*Range;
	
	float3 viewPos = float3(sin(aHor), sin(aVer), cos(aHor));

	float3 worldPos = mul(_InvViewMatrix, viewPos);
	
	//float beam_pos = (id.x / BeamCount);
	//int j = floor(mod((PingNumber - clamp(beam_pos, 0, BeamCount)), Wedge_MemoryAmount));
	//uv = uv + float2(SWS_x, SWS_y)*d_dim.xy*SwathSpacing*j;
	

	//float c = float(BeamBuffer[id.x].x) / 512. * cos(abs((coordX - 0.5)*HorisontalFOV*0.0174533))*Range;
	//c = remap(0, 1, ZeroLevel, UpperLevel, c);
	
	float3 u = float3(viewPos.x, viewPos.y, -viewPos.z)*r;
	u = mul(_InvViewMatrix, float4(u.x,0, u.z,1));
	//u = mul(_InvViewMatrix, float4(10*(2*rand(id.xy)-1), 0, -rand(id.xy)*10, 1));
	PosBuffer[PingNumber*BeamCount + id.x ] = float3(u.x,u.y,u.z);


	BeamHistoryBuffer[PingNumber*BeamCount + id.x] = uint4(BeamBuffer[id.x].x, BeamBuffer[id.x].y, uint(10000 * u.y), uint(FlexModeEnabled));
}