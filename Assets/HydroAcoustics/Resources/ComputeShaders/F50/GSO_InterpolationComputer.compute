#pragma kernel RenderInPolar
#pragma kernel RemapQuad

#pragma kernel RemapQuad

#pragma kernel RenderInCartesian

#pragma kernel FillSideScanScroll
#pragma kernel ShiftWaterColumnScroll

#pragma kernel RenderSideScanFinal
#pragma kernel RenderDepthRuler

#pragma kernel RenderWaterColumnFinal
#pragma kernel Zoom_RenderInPolar
#pragma kernel Zoom_RenderInCartesian
#pragma kernel RenderDetect
#pragma kernel DrawWedgeHistory
#include "../SonarsInterpolationBase.cginc"
Texture2D<float4> Source;
Texture2D<float4> DistStrip;
Texture2D<float4> Ruler;

SamplerState _BilinearClamp;
RWTexture2D<float4> Destination;
Texture2D<float4> Noise;

Texture2D<uint> Read_UintTex_1;
Texture2D<uint> Read_UintTex_2;
//Fields
float Resolution;
float CurrentRotAngle;
float DiscreteAngleStep;

float Interpolation;
float HorisontalFOV;
float VerticalFOV;
float MinimumRange,MaximumRange;
float MinRadius, MaxRadius;
float Zoom_angle1, Zoom_angle2;

//SideScan
float Scroll;
float LookAngle;

//Ruler Variables//
float WindowsRatio;
float RulerScale;
float ShowDivisions;
float3 RulerBackground, RulerScaleColor, RulerDivisionsColor, RulerDigitsColor;


//WaterColumn Variables
float Time;
uint WC_GridOn;
uint WC_EventLine;
uint WC_GridCount;
float4 WC_GridColor;

//UI
float4 _GridColor;
int CrossCount, GridCount, LinesCount;
uint Rings;

float ShowRings, ShowSector, ApplyZoom;

float2 Offset;
float Scale_factor;
float Rotation;
float Thickness;

//Zoom//
float2 MouseCoords;
float2 ZoomBox, ZoomParams;
float4 BoxColor;
float BoxSize;

//ColorPalette
float Gamma;
float4 _Colors[8];
int _ColorsCount;
float LowerFactor, MiddleFactor;


//Flex Mode
float BeamCount;
float BeamCount_left, BeamCount_mid;
float LeftUVBorder, RightUVBorder;
float OutBeamDensity, InBeamDensity, DefaultBeamDensity;
float FlexModeEnabled;

//---//
float MirrorImage, ShowSSGrid;

//Methods
float3 LerpColorPixels(float depth) {
	depth = depth * step(LowerFactor, MiddleFactor);
	depth = remap(0, 1, LowerFactor, MiddleFactor, depth);

	//depth = depth * step(MiddleFactor, depth);
	float sT = clamp(depth, 0, 1) * (float)(_ColorsCount - 1);
	float3 oldColor = _Colors[floor(sT)].rgb;
	float3 newColor = _Colors[ceil(sT)].rgb;
	float newT = sT - floor(sT);

	float3 color = lerp(oldColor, newColor, newT);
	return color;
}
float4 SampleBilinear(Texture2D tex, float2 uv, float4 texelSize)
{
	float2 uv_texels = uv * texelSize.zw + float2(0.5, 0.5);

	float2 UVmin = float2((uv.x - texelSize.x*0.5)*texelSize.z, (uv.y -  texelSize.y * 0.5)*texelSize.w);

	float2 UVmax = float2((uv.x + texelSize.x*0.5)*texelSize.z, (uv.y +  texelSize.y * 0.5)*texelSize.w);

	float4 uv_min_max = float4(UVmin, UVmax);

	float2 uv_frac = frac(uv_texels);
	float4 texelA = Source[float2(uv_min_max.xy)];
	float4 texelB = Source[float2(uv_min_max.xw)];
	float4 texelC = Source[float2(uv_min_max.zy)];
	float4 texelD = Source[float2(uv_min_max.zw)];

	return lerp(lerp(texelA, texelB, uv_frac.y), lerp(texelC, texelD, uv_frac.y), uv_frac.x);
}

float SampleLinearY(Texture2D tex, float2 uv, float4 texelSize) {

	float2 uv_texels = uv * texelSize.zw + float2(0, 0.5);
	float2 y_min_max = float2(floor(uv_texels.y) - 0.5, floor(uv_texels.y) + 0.5);
	float uv_frac = frac(uv_texels.y);

	float2 uv1 = float2(uv_texels.x, y_min_max.x);
	float2 uv2 = float2(uv_texels.x, y_min_max.y);

	float4 colorA = tex[uv1];
	float4 colorB = tex[uv2];
	return lerp(colorA, colorB, uv_frac).r;
}

float DrawCross(float2 coord, float4 dim,float zoom)
{
	float m=0;
	for (int i = 0; i < CrossCount; i++) {
		
		float2 tempXY = coord * dim.xy;
		tempXY += 0.5;
		tempXY = rotateUV(tempXY, i * 90);

		float y = 1 / clamp(Scale_factor, 0, 0.5)*2 ;
		float norm = lerp(dim.w*dim.x, 1., i);
		float l = LineSegment(tempXY, float2(-y, 0.5), float2(y, 0.5));
		l = LineSharpen(l, Thickness*zoom /norm, dim.zw);
		m += l;
	}
	return m;
}
float DrawSector(float2 normCoord, float2 angle_rad, float4 dim,float rings,float zoom)
{
	float S1_angle = Rotation + (90 - HorisontalFOV / 2);
	float S2_angle = Rotation + (90 + HorisontalFOV / 2);
	float l = 0; 
	float s_lines = 0;
	for (float i = 0; i < LinesCount+2; i++) 
	{
		float a = S1_angle + HorisontalFOV * (i/ (LinesCount+1));
		float2 cosin_s1 = float2(-cos(a / 57.29), sin(a / 57.29));
		l = LineSegment(normCoord, float2(0, 0), cosin_s1 / 2);
		s_lines += LineSharpen(l, Thickness *zoom, dim.zw);
	}

	float In;
	if (angle_rad.x > 0 && angle_rad.x < HorisontalFOV) In = 1;
	else In = 0;
	In = lerp(1 - In, In, 1);
	float s_rings = (1 - step(Thickness*5*zoom *Rings, 1 - frac(rings)))*In;
	
	return (s_rings + s_lines)*step(MinimumRange, angle_rad.y) +(1 - step(Thickness * 5 * zoom / (0.01+MinimumRange), 1 - frac(clamp(angle_rad.y / MinimumRange, 0, 1))))*In;

}

float DrawGrid(float2 coord, float4 dim,float zoom) {

	float g = 0;
	for (int j = 0; j < GridCount; j++)
	{
		float2 tempXY = coord * dim.xy;

		tempXY += 0.5;
		tempXY = rotateUV(tempXY, j*90.);
		float r = lerp(dim.w*dim.x, 1., j);

		float nAbs = r;
		float norm = r;
		//nAbs = dim.w*dim.x
		float y = 1/clamp(Scale_factor,0,0.5)*2;
		float l = LineSegment(tempXY, float2(-y, 0.5), float2(y, 0.5));
		l = LineSharpen(l, Thickness *zoom, dim.zw);
		g += l;
		
		for (uint i =0; i <= (Rings-1); i++) {
			float uv_offset = 0.5*(1 + nAbs - norm * ((float)i / Rings));
			float l = LineSegment(tempXY, float2(uv_offset, -y), float2(uv_offset, y));
			float draw = step(0.5,uv_offset );
			l = LineSharpen(l, Thickness  *zoom, dim.zw);
			g += l*draw;

			uv_offset = 0.5*(1	- nAbs+norm * ((float)i / Rings));
			l = LineSegment(tempXY, float2(uv_offset, -y), float2(uv_offset, y));
			draw = step(uv_offset, 0.5);
			//draw = 1;
			l = LineSharpen(l, Thickness *zoom, dim.zw);
			g += l*draw;
		}
	}
	return g;
}


float DrawGridPolar(float2 coord, float4 dim, float zoom) {

	float g = 0;
	for (int j = 0; j < GridCount; j++)
	{
		float2 tempXY = coord * dim.xy;

		tempXY += 0.5;
		tempXY = rotateUV(tempXY, j*90.);
		float r = 1;


		float nAbs = lerp(r /(1-MinRadius),r,1-j);
		float norm = lerp(r / (1 - MinRadius)*(1+MinRadius),r,1-j);
		nAbs = r;
		norm = r;
		//nAbs = dim.w*dim.x
		float y = 1 / clamp(Scale_factor, 0, 0.5) * 2;
		float l = LineSegment(tempXY, float2(-y, 0.5), float2(y, 0.5));
		l = LineSharpen(l, Thickness *zoom, dim.zw);
		g += l;
		for (uint i = 0; i <= (Rings - 1); i++) {
			float uv_offset = 0.5*(1 + (j+1)*nAbs - (j + 1)*norm * ((float)i / Rings));
			float l = LineSegment(tempXY, float2(uv_offset, -y), float2(uv_offset, y));
			float draw = step(0.5, uv_offset);
			l = LineSharpen(l, Thickness  *zoom, dim.zw);
			g += l * draw;

			uv_offset = 0.5*(1 - (j + 1)*nAbs + (j + 1)*norm * ((float)i / Rings));
			l = LineSegment(tempXY, float2(uv_offset, -y), float2(uv_offset, y));
			draw = step(uv_offset, 0.5);
			l = LineSharpen(l, Thickness *zoom, dim.zw);
			g += l * draw ;
		}
	}
	return g;
}



//For WaterColumn
float4 uvOffsetArray[16];
int uvArrayCount;

float DrawEventLine(float2 coord, float4 dim) {

	// Normalized pixel coordinates (from 0 to 1)
	float2 uv = coord * dim.xy;

	float s = 0.;
	for (int i = 0; i < uvArrayCount; i++)
	{

		float uv_offset = -0.5 + uvOffsetArray[floor(i / 4)][i % 4];

		float s1 = LineSegment(uv, float2(uv_offset, 0), float2(uv_offset, 1));

		s += LineSharpen(s1, Thickness, dim.zw);
	}
	return s;
}

float DrawHorisontalGrid(float2 coord, float4 dim) {

	float g = 0;

	float2 tempXY = coord * dim.xy;

	float norm = 1;
	float y = 4;
	float l;
	for (uint i = 1; i <= (WC_GridCount); i++) {
		float uv_offset = (norm * ((float)(i) / (WC_GridCount + 1)));
		float l = LineSegment(tempXY, float2(-y, uv_offset), float2(y, uv_offset));
		l = LineSharpen(l, Thickness, dim.zw);
		g += l;
	}
	return g;
}


/////////Kernels////////////


[numthreads(32, 32, 1)]
void RemapQuad(uint2 id : SV_DispatchThreadID)
{
	float4 s_dim;
	//s_dim = GetDimensionsFrom(Read_UintTex_2);
	Read_UintTex_2.GetDimensions(s_dim.z, s_dim.w);
	s_dim.xy = 1 / s_dim.zw;

	int res = 64;

	float4 d_dim;
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;


	float2 uv = id.xy*d_dim.xy;
	//uv.x = 2;
	uv.y *= s_dim.w;
	//define in which UV zone beam is placed: 
	float leftZone = step(uv.x, LeftUVBorder);
	float midZone = step(LeftUVBorder, uv.x)*step(uv.x, RightUVBorder);
	float rightZone = step(RightUVBorder, uv.x);

	float flexX = leftZone * (uv.x)/ LeftUVBorder + midZone * (uv.x - LeftUVBorder)/(RightUVBorder- LeftUVBorder) + rightZone * (uv.x - RightUVBorder)/(1-RightUVBorder);
	//float flexX = leftZone * (uv.x) + midZone * (uv.x - LeftUVBorder) + rightZone * (uv.x - RightUVBorder);
	float texCoordX = (flexX *FlexModeEnabled + (1 - FlexModeEnabled)*uv.x);
	texCoordX *= d_dim.z;
	float beam_id = flexX * (leftZone*BeamCount_left + midZone * BeamCount_mid + rightZone * (BeamCount - BeamCount_left - BeamCount_mid));
	beam_id = beam_id * FlexModeEnabled + (1 - FlexModeEnabled)*uv.x*BeamCount;
	//texCoordX += 0.5;
	float B_density = (rightZone + leftZone)*OutBeamDensity + midZone * InBeamDensity;
	B_density = FlexModeEnabled * B_density + (1 - FlexModeEnabled)*(DefaultBeamDensity);
	float InZoneIndex = floor(texCoordX / (B_density));
	float startIndex =leftZone*1+midZone * (BeamCount_left) + rightZone * (BeamCount_mid + BeamCount_left); //+0.5
	startIndex = FlexModeEnabled * (startIndex);
	float TrueBeamIndex = startIndex + beam_id;
	//TrueBeamIndex = uv.x*BeamCount;

	float2 b_Coords = float2(TrueBeamIndex, uv.y);
	//float x = R_BeamBuffer[b_Coords.x+b_Coords.y*BeamCount];
	//float x = R_BeamBuffer[TrueBeamIndex + id.y*BeamCount];
	//Destination[id.xy] = R_BeamBuffer[TrueBeamIndex + id.y*BeamCount];

	//float i;
	//float fract = abs(1-2*frac((texCoordX +B_density/2) / B_density));
	float fract = frac((texCoordX) / B_density);
	float2 c = id.xy*d_dim.xy;
	//c.x = PaniniProjectionScreenPosition(c * 2 - 1, HorisontalFOV).x + 0.5;
	//float x  = 1-step(Source[b_Coords / BeamCount*s_dim.zw],0);
	//Destination[id.xy] = Source[b_Coords];
	//float2 dx = float2(1, 0);
	//float2 dy = float2(0, 1);
	//Destination[c*d_dim.zw] = SampleLinearY(Source, b_Coords *s_dim.xy, s_dim, fract);
	//Destination[c*d_dim.zw] = clamp(beam_id,0,512) / float(BeamCount);
	
	Destination[c*d_dim.zw] = float(max(Read_UintTex_1[b_Coords], Read_UintTex_2[b_Coords]))/10000;
	
	//Destination[c*d_dim.zw] = fract;
	//Destination[c*d_dim.zw - dx] = Source[b_Coords];
}




float SideScanLook;
[numthreads(32, 32, 1)]
void RenderInPolar(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{

	float4 s_dim, d_dim;
	s_dim = GetDimensionsFrom(Source);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	//Destination[id.xy] = Source[id.xy * d_dim.xy * s_dim.zw];
	//Destination[id.xy] = SampleBilinear(Source, id.xy*d_dim.xy, s_dim, sign(DiscreteAngleStep)).r;
	//Destination[id.xy] = SampleLinearY(Source, id.xy*d_dim.xy, s_dim).r;
	float depth;

	float2 dx = float2(1, 0);
	float2 dy = float2(0, 1);

	float radius_uv_y = id.y*d_dim.y;
	float remappedRadius = remap(MinRadius, MaxRadius, 0, 1, id.y*d_dim.y);
	float2 coord = float2(id.x*d_dim.x, remappedRadius)*s_dim.zw;

	depth = SampleBilinear(Source, coord*s_dim.xy, s_dim).r*step(radius_uv_y, 1)*step(MinimumRange, radius_uv_y + 0.01);
	//float detect = Noise[float2(coord)*float2(BeamCount, 512)].r * 10 * step(0.5, DetectModeEnabled);

	float grid = DrawGridPolar(id.xy -float2(d_dim.z/2,0), d_dim, 1 / Scale_factor)*step(MinimumRange, radius_uv_y + 0.01);
	float4 Scolor = float4(LerpColorPixels(pow(abs(depth), Gamma)), 1);

	//Scolor = lerp(Scolor, float4(0, 2, 0, 1), step(0.1, detect));

	float2 center = (MouseCoords*d_dim.zw);
	float2 zoom_wh = ZoomBox / 2 * ZoomParams.x / 100;
	float hollow = BoxSize;
	float box = sdBox(id.xy - center, zoom_wh, hollow)*ApplyZoom;

	float4 color = lerp(Scolor, _GridColor, grid*_GridColor.w);


	color = lerp(color, BoxColor, box);
	Destination[id.xy] = pow(abs(color), 2.2);
}

[numthreads(32, 32, 1)]
void RenderInCartesian(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	const float UNITY_PI = 3.14159265359;
	float4 s_dim,d_dim; 
	s_dim = GetDimensionsFrom(Source);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;
	
	float minRes = min(d_dim.z, d_dim.w);

	float2 uv_from_center = float2(id.xy - 0.5 *d_dim.zw);
	//uv_from_center.x *= MirrorImage;
	uv_from_center = Scale_UV(uv_from_center, Offset, Scale_factor, d_dim);
	float radius_uv_y;
	float pixel_angle;
	GetAngleCoordAndRadiusUV(uv_from_center / minRes, radius_uv_y, pixel_angle);

	//radius_uv_y *= step(radius_uv_y,MaxRadius);
	//pixel_angle = 360 - pixel_angle;
	pixel_angle -= (Rotation + 90-  HorisontalFOV / 2)%360;
	
	pixel_angle  = (360+  pixel_angle )% 360;
	//pixel_angle *= MirrorImage;
	//Draw Rings
	float ringsMain = clamp(radius_uv_y * Rings, 0, Rings);
	float rings = (1 - step(Thickness *5 /Scale_factor * Rings, 1 - frac(ringsMain)));
	
	
	//Draw SideScan Scale
	float m = 0.03;
	float2 lUv = uv_from_center * d_dim.yy+float2(0.5, 0.5);
	
	lUv = rotateUV(lUv,180+ Rotation);
	lUv.y = clamp(lUv.y, 0, 0.5-m/2);
	lUv.x -= 0.5;
	float2 uvSym = float2(lUv.x, (1 + Thickness)*(lUv.y) % (m));
	float Line = LineSegment(uvSym, float2(0,m/3.), float2(0, 2.*m/3.));
	Line = LineSharpen(Line, Thickness, d_dim.zw) ;
	
	m = 0.1;
	//lUv = uv_from_center * d_dim.xy +float2(0, 0.5-m/2);
	//lUv.y = clamp(lUv.y, 0, 0.5-m/1.8);
	//lUv.y = clamp(lUv.y, 0, 0.5 - m / 2);
	//lUv.x -= 0.5;
	uvSym = float2(lUv.x, (1 + Thickness)*(lUv.y-m/2) % (m));
	float sLine = LineSegment(uvSym, float2(-0.02, m/2), float2(0.02, m/2));
	Line += LineSharpen(sLine, Thickness, d_dim.zw);

	float main = Line;
	main *= ShowSector;


	//Draw Sector Rings and Lines
	float sector = DrawSector(uv_from_center / minRes, float2(pixel_angle,radius_uv_y), d_dim, ringsMain, 1 / Scale_factor);
	sector *= ShowSector ;
	//sector = 0;
	//DrawZoomWindow
	float2 center = (MouseCoords*d_dim.zw);
	float2 zoom_wh = ZoomBox / 2 * ZoomParams.x  / 100;
	float hollow = BoxSize;
	float box = sdBox(id.xy - center, zoom_wh, hollow)*ApplyZoom;

	//pixel_angle = x;	
	float remapped_radius = remap(MinRadius, MaxRadius, 0, 1, radius_uv_y);
	//Scale_UV(id.xy - center, Offset, 1, d_dim)

	float2 uv_sample = float2((1 - MirrorImage) / 2 + MirrorImage * (pixel_angle) / HorisontalFOV, remapped_radius);
	float depth = Source[uv_sample*s_dim.zw].r*step(radius_uv_y, 1)*step(MinimumRange, radius_uv_y);
	//depth = Source.SampleLevel(_BilinearClamp,float2(pixel_angle / HorisontalFOV, radius_uv_y), 0)*step(radius_uv_y, MaxRadius)*step(0,pixel_angle / HorisontalFOV);
	
	depth = SampleBilinear(Source, uv_sample, s_dim).r*step(radius_uv_y, 1)*step(MinimumRange, radius_uv_y)*step(0, (1-MirrorImage)/2+MirrorImage*pixel_angle / HorisontalFOV);;
	//float detect = Noise[float2(pixel_angle / HorisontalFOV, remapped_radius)*float2(BeamCount, 512)].r * 10 *step(0.5, DetectModeEnabled);
	//pixel_angle = remap(0, 1, Zoom_angle1, Zoom_angle2, pixel_angle / 130);
	//depth = pixel_angle;
	//depth += depth *0.1* (2 * rand(id.xy) - 1)*step(0.01, depth);
	float4 Scolor = float4(LerpColorPixels(pow(abs(depth),Gamma)),1);
	//Scolor = lerp(Scolor, float4(0,2,0,1), step(0.1,detect));
	float4 color = lerp(Scolor, _GridColor, main*step(0,ShowSSGrid) + sector *_GridColor.w);
	
	color = lerp(color, BoxColor, box);
	//color = main;
	Destination[id.xy] = pow(abs(color), 2.2);
	//Destination[id.xy] = uv_sample.x;
	//Destination[id.xy] =float4(FlexModeEnabled, FlexModeEnabled, FlexModeEnabled,1);
}


float2 OriginTexWH;


[numthreads(32, 32, 1)]
void Zoom_RenderInPolar(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{

	const float UNITY_PI = 3.1415;
	float4 s_dim, d_dim;
	s_dim = GetDimensionsFrom(Source);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	float4 dim = float4(1 / OriginTexWH, OriginTexWH);

	float2 Boxcenter = MouseCoords * OriginTexWH;
	float zoom = ZoomParams.x / 100;
	float2 LBCorner = Boxcenter - ZoomBox / 2 * zoom;
	float2 coord = float2(id.x + Zoom_angle1 * s_dim.z, id.y);
	coord = id.xy;
	float2 relUV = (LBCorner + coord * zoom)/OriginTexWH;
	float minRes = min(OriginTexWH.x, OriginTexWH.y);

	float2 dx = float2(1, 0);
	float2 dy = float2(0, 1);

	float radius_uv_y = relUV.y;
//	float2 coord = float2(id.x*d_dim.x, radius_uv_y)*s_dim.zw;

	float pixel_angle = remap(0, 1, Zoom_angle1, Zoom_angle2, relUV.x);
	pixel_angle = id.x*d_dim.x;
	float remappedRadius = remap(MinRadius, MaxRadius, 0, 1, relUV.y);
	float depth = Source[float2((pixel_angle), remappedRadius)*s_dim.zw].r*step(radius_uv_y, MaxRadius)*step(MinimumRange, radius_uv_y + 0.01);
	//depth += depth *0.1* (2 * rand(id.xy) - 1)*step(0.01, depth);

	float grid = DrawGridPolar(relUV*OriginTexWH -float2(OriginTexWH.x/2,0), dim, zoom)*step(MinimumRange, radius_uv_y + 0.01);
	float4 Scolor = float4(LerpColorPixels(pow(abs(depth), Gamma)), 1);

	float4 color = lerp(Scolor, _GridColor, (grid)*_GridColor.w);

	Destination[id.xy] = pow(abs(color), 2.2);
}

[numthreads(32, 32, 1)]
void Zoom_RenderInCartesian(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	const float UNITY_PI = 3.1415;
	float4 s_dim, d_dim;
	s_dim = GetDimensionsFrom(Source);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;
	
	float4 dim = float4(1 / OriginTexWH, OriginTexWH);

	float2 Boxcenter = MouseCoords * OriginTexWH;
	float zoom = ZoomParams.x / 100;
	float2 LBCorner = Boxcenter - ZoomBox /2 *zoom ;
	float2 coord = float2(id.x + Zoom_angle1 * s_dim.z, id.y);
	coord = id.xy;
	float2 relUV = (LBCorner + coord *zoom);
	float minRes = min(OriginTexWH.x, OriginTexWH.y);

	float2 uv_from_center = float2(relUV - 0.5 *OriginTexWH);
	uv_from_center = Scale_UV(uv_from_center, Offset, Scale_factor, dim);
	float radius_uv_y;
	float pixel_angle;
	GetAngleCoordAndRadiusUV(uv_from_center / minRes, radius_uv_y, pixel_angle);

	pixel_angle -= (Rotation + 90 - HorisontalFOV / 2) % 360;
	pixel_angle = (360 + pixel_angle) % 360;
	
	
	//Draw Rings
	float ringsMain = clamp(radius_uv_y * Rings, 0, Rings);
	float rings = (1 - step(Thickness*5*zoom*Rings, 1 - frac(ringsMain)));

	//Draw Spinning Line
	float pc = (CurrentRotAngle) / 57.29;
	float2 cosin = float2(sin(pc), cos(pc));

	float l = LineSegment(uv_from_center / minRes, float2(0, 0), cosin);

	l = LineSharpen(l, Thickness  *zoom, dim.zw);


	//Draw Cross
	float cross = DrawCross(uv_from_center, dim, zoom*2);


	//Draw Sector Rings and Lines
	float sector = DrawSector(uv_from_center / minRes, float2(pixel_angle, radius_uv_y), dim, ringsMain, zoom);
	sector *= ShowSector;

	pixel_angle /= HorisontalFOV;
	float depth;
	//pixel_angle = remap(0.0, 1, Zoom_angle1, Zoom_angle2, pixel_angle);
	pixel_angle = remap(0, 1, Zoom_angle1, Zoom_angle2, pixel_angle );

	float remapped_radius = remap(MinRadius, MaxRadius, 0, 1, radius_uv_y);
	depth = Source[float2((pixel_angle) , remapped_radius)*s_dim.zw].r*step(radius_uv_y, MaxRadius)*step(MinimumRange, radius_uv_y);

	float4 Scolor = float4(LerpColorPixels(pow(depth, Gamma)), 1);
	float4 color = lerp(Scolor, _GridColor, (sector )*_GridColor.w); 
	Destination[id.xy] = pow(color, 2.2);
}

/*
	[numthreads(16, 16, 1)]
	void FillSideScanScroll(uint3 groupID : SV_GroupID,
		uint3 groupThreadID : SV_GroupThreadID,
		uint groupIndex : SV_GroupIndex,
		uint3 id : SV_DispatchThreadID)
	{
		float4 s_dim, d_dim, n_dim;
		s_dim = GetDimensionsFrom(Source);
		n_dim = GetDimensionsFrom(DistStrip);
		Destination.GetDimensions(d_dim.z, d_dim.w);
		d_dim.xy = 1 / d_dim.zw;

		float4 s = Source[id.xy + float2(0,Scroll)];
		float delta = (id.y % (Scroll)) ;

		float uvx = abs(id.x*s_dim.x - 0.5) * 2;
		float d1 = SampleLinearY(DistStrip, float2(0, uvx), n_dim); //+delta*s_dim.x
		float d2 = SampleLinearY(DistStrip, float2(1-s_dim.x, uvx), n_dim); //1-s_dim.x*(1+delta)
		float resD = lerp(d1, d2, step(0,id.x*s_dim.x-0.5));
		//d = lerp(s, d, 1-delta).r; bilinear filtering
		float flag = step(d_dim.w-id.y-Scroll, 0);
		float col = lerp(s, resD, flag);
		Destination[id.xy] = col;
	}
	*/


StructuredBuffer<uint3> BeamBuffer;
[numthreads(16, 16, 1)]
void FillSideScanScroll(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	float4 s_dim, d_dim, n_dim;
	s_dim = GetDimensionsFrom(Source);
	n_dim = GetDimensionsFrom(DistStrip);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	float4 s = Source[id.xy + float2(0, Scroll)];
	float delta = (id.x % (Scroll));

	float d = DistStrip[float2(id.x*s_dim.x*n_dim.z,0)]; //+delta*s_dim.x
		

	//float resD = lerp(d1, d2, step(0, id.x*s_dim.x - 0.5));
	//d = lerp(s, d, 1-delta).r; bilinear filtering
	float flag = step(d_dim.w - id.y - Scroll, 0);
	float col = lerp(s, d, flag);
	Destination[id.xy] = col;
}

[numthreads(32, 32, 1)]
void RenderSideScanFinal(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	
	float4 s_dim, r_dim, d_dim;
	s_dim = GetDimensionsFrom(Source);
	r_dim = GetDimensionsFrom(Ruler);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	float scale = 1.05;

	float2 uv = ((id.xy*d_dim.xy) - 0.5);
	uv *= scale;
	//uv.y += (scale - 1) / 2;
//	uv = uv_from_center + 0.5;
	uv.y -= (scale - 1) / 2;
	float2 uv_from_center = uv;
	uv += 0.5;
	float2 coord = uv * s_dim.zw;
	float2 coordSource = float2(uv.x,uv.y / WindowsRatio)*s_dim.zw;
	float2 coordRuler = float2(uv.x ,(uv.y - WindowsRatio) / (1 - WindowsRatio))*r_dim.zw;

	float depth = Source[coordSource];
	float4 Scolor =	float4(LerpColorPixels(pow(abs(depth), Gamma)), 1);
		
	float3 ruler = Ruler[coordRuler].xyz;

	float box = sdBox((uv_from_center)*d_dim.zw, d_dim.zw / 2, 6);
	float3 color = lerp(_Colors[0], RulerDigitsColor,box);

	float m = 1. / (RulerScale - 1.);
	float thickness = 0.002;

	float2 uvSym = float2(((1 + thickness)) *uv_from_center.x % (m), uv.y);
	float Line = LineSegment(uvSym, float2(0.00, -0.02), float2(0, 0));

	Line = LineSharpen(Line, thickness, d_dim.zw);
	color = lerp(RulerDigitsColor, color, 1 - Line);
	color = lerp(color,(Scolor.rgb * step(uv.y, WindowsRatio) + ruler * step(WindowsRatio, uv.y)),step(0, uv.x)*step(uv.x, 1)*step(0, uv.y)*step(uv.y, 1));

	Destination[id.xy] = float4(pow(color, 2.2).rgb, 1);

}
/*
[numthreads(16, 16, 1)]
void RenderDepthRuler(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	const float UNITY_PI = 3.1415;
	float4 ds_dim, d_dim;
	ds_dim = GetDimensionsFrom(DistStrip);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;
	float2 uv = (id.xy)*d_dim.xy;

	//
	float uvx = abs(uv.y - 0.5) * 2;
	

	//sample with offset
	float d1_up = SampleLinearY(DistStrip, float2(0, uvx+ ds_dim.y), ds_dim);
	float d1_down = SampleLinearY(DistStrip, float2(0, uvx - ds_dim.y), ds_dim);

	float d2_up = SampleLinearY(DistStrip, float2(1 - ds_dim.x, uvx + ds_dim.y), ds_dim);
	float d2_down = SampleLinearY(DistStrip, float2(1 - ds_dim.x, uvx - ds_dim.y), ds_dim);

	float resDup = lerp(d1_up, d2_up, step(0, id.y*d_dim.y - 0.5));
	float resDdown = lerp(d1_down, d2_down, step(0, id.y*d_dim.y - 0.5));
	

	float minRes = min(resDup, resDdown);
	float maxRes = max(resDup, resDdown);

	minRes = minRes * step(LowerFactor, MiddleFactor);
	minRes = remap(0, 1, LowerFactor, MiddleFactor, minRes);
	minRes = clamp(minRes, 0, 1);

	maxRes = maxRes * step(LowerFactor, MiddleFactor);
	maxRes = remap(0, 1, LowerFactor, MiddleFactor, maxRes);
	maxRes = clamp(maxRes, 0, 1);

	float scale = step(uv.x,0.03+maxRes)*step(minRes, uv.x);
	float m = 1 / (RulerScale - 1);
	float thickness = 0.003;

	float2 uvSym = float2(uv.x, (1 + thickness)*(uv.y) % (m / 5));
	float Line = LineSegment(uvSym, float2(0.6, 0.), float2(0.65, 0));
	Line = LineSharpen(Line, thickness, d_dim.ww) *ShowDivisions;

	uvSym = float2(uv.x, (1 + thickness)*uv.y % (m));
	float sline = LineSegment(uvSym, float2(0.6, 0.), float2(0.85, 0.));
	Line += LineSharpen(sline, thickness*1.5, d_dim.ww);
	Line = 0;
	float3 col = lerp(RulerBackground, RulerScaleColor, scale);
	col = lerp(col, RulerDivisionsColor, Line);
	Destination[id.xy] = float4(col, 1);
}
*/

[numthreads(16, 16, 1)]
void ShiftWaterColumnScroll(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	float4 s_dim, d_dim, n_dim;
	s_dim = GetDimensionsFrom(Source);
	n_dim = GetDimensionsFrom(DistStrip);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	float4 s = Source[id.xy - float2(Scroll,0)];
	float delta = (id.x % (Scroll));

	float d = DistStrip[float2(0, (1-id.y*s_dim.y)*n_dim.w)]; //+delta*s_dim.x


	//float resD = lerp(d1, d2, step(0, id.x*s_dim.x - 0.5));
	//d = lerp(s, d, 1-delta).r; bilinear filtering
	float flag = step(id.x -Scroll,0);
	float col = lerp(s, d, flag);
	Destination[id.xy] = col;
}


[numthreads(32, 32, 1)]
void RenderWaterColumnFinal(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{

	float4 s_dim, r_dim, d_dim;
	s_dim = GetDimensionsFrom(Source);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;

	float2 uv = (id.xy*d_dim.xy);

	float2 coord = uv * s_dim.zw;
	float2 coordSource = float2(uv.x , uv.y)*s_dim.zw;

	//depth = SampleBilinear(Source, coord*s_dim.xy, s_dim).r;
	float depth = Source[coordSource];
	float grid = WC_GridOn * DrawHorisontalGrid(id.xy - float2(d_dim.z / 2, 0), d_dim) + WC_EventLine * DrawEventLine(id.xy - float2(d_dim.z / 2, 0), d_dim);
	float4 Scolor = float4(LerpColorPixels(pow(abs(depth), Gamma)), 1);

	float3 color = lerp(Scolor, WC_GridColor, grid*_GridColor.w).xyz;

	Destination[id.xy] = float4(pow(color, 2.2), 1);

}
/*
[numthreads(16, 16, 1)]
void RenderDepthRuler(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	const float UNITY_PI = 3.1415;
	float4 ds_dim, d_dim;
	ds_dim = GetDimensionsFrom(DistStrip);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;
	float2 uv = (id.xy)*d_dim.xy;

	//
	float uvx = abs(uv.y - 0.5) * 2;


	//sample with offset
	float d1_up = SampleLinearY(DistStrip, float2(0, uvx+ ds_dim.y), ds_dim);
	float d1_down = SampleLinearY(DistStrip, float2(0, uvx - ds_dim.y), ds_dim);

	float d2_up = SampleLinearY(DistStrip, float2(1 - ds_dim.x, uvx + ds_dim.y), ds_dim);
	float d2_down = SampleLinearY(DistStrip, float2(1 - ds_dim.x, uvx - ds_dim.y), ds_dim);

	float resDup = lerp(d1_up, d2_up, step(0, id.y*d_dim.y - 0.5));
	float resDdown = lerp(d1_down, d2_down, step(0, id.y*d_dim.y - 0.5));


	float minRes = min(resDup, resDdown);
	float maxRes = max(resDup, resDdown);

	minRes = minRes * step(LowerFactor, MiddleFactor);
	minRes = remap(0, 1, LowerFactor, MiddleFactor, minRes);
	minRes = clamp(minRes, 0, 1);

	maxRes = maxRes * step(LowerFactor, MiddleFactor);
	maxRes = remap(0, 1, LowerFactor, MiddleFactor, maxRes);
	maxRes = clamp(maxRes, 0, 1);

	float scale = step(uv.x,0.03+maxRes)*step(minRes, uv.x);
	float m = 1 / (RulerScale - 1);
	float thickness = 0.003;

	float2 uvSym = float2(uv.x, (1 + thickness)*(uv.y) % (m / 5));
	float Line = LineSegment(uvSym, float2(0.6, 0.), float2(0.65, 0));
	Line = LineSharpen(Line, thickness, d_dim.ww) *ShowDivisions;

	uvSym = float2(uv.x, (1 + thickness)*uv.y % (m));
	float sline = LineSegment(uvSym, float2(0.6, 0.), float2(0.85, 0.));
	Line += LineSharpen(sline, thickness*1.5, d_dim.ww);
	Line = 0;
	float3 col = lerp(RulerBackground, RulerScaleColor, scale);
	col = lerp(col, RulerDivisionsColor, Line);
	Destination[id.xy] = float4(col, 1);
}
*/



[numthreads(16, 16, 1)]
void RenderDepthRuler(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	const float UNITY_PI = 3.1415;
	float4 ds_dim, d_dim;
	ds_dim = GetDimensionsFrom(DistStrip);
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = 1 / d_dim.zw;
	float2 uv = (id.xy)*d_dim.xy;

	//
	float uvx = abs(uv.y - 0.5) * 2;


	//sample with offset
	

	float d1 = DistStrip[float2(uv.x*ds_dim.z+1, 0)];
	float d2 = DistStrip[float2(uv.x*ds_dim.z - 1, 0)];


	float minRes = min(d1, d2);
	float maxRes = max(d1, d2);

	minRes = minRes * step(LowerFactor, MiddleFactor);
	minRes = remap(0, 1, LowerFactor, MiddleFactor, minRes);
	minRes = clamp(minRes, 0, 1);

	maxRes = maxRes * step(LowerFactor, MiddleFactor);
	maxRes = remap(0, 1, LowerFactor, MiddleFactor, maxRes);
	maxRes = clamp(maxRes, 0, 1);

	float scale = step(uv.y, maxRes) *step(minRes, uv.y);
	float m = 1 / (RulerScale - 1);
	float thickness = 0.03;

	float2 uvSym = float2(uv.x, (1 + thickness)*(uv.y) % (m / 5));
	float Line = LineSegment(uvSym, float2(0.6, 0.), float2(0.65, 0));
	Line = LineSharpen(Line, thickness, d_dim.ww) *ShowDivisions;

	uvSym = float2(uv.x, (1 + thickness)*uv.y % (m));
	float sline = LineSegment(uvSym, float2(0.6, 0.), float2(0.85, 0.));
	Line += LineSharpen(sline, thickness*1.5, d_dim.ww);
	Line = 0;
	float3 col = lerp(RulerBackground, RulerScaleColor, scale);
	col = lerp(col, RulerDivisionsColor, Line);
	Destination[id.xy] = float4(col, 1);
}
/*
[numthreads(64, 1, 1)]
void RenderDetect(uint3 groupID : SV_GroupID,
	// 3D ID of thread group; range depends on Dispatch call
	uint3 groupThreadID : SV_GroupThreadID,
	// 3D ID of thread in a thread group; range depends on numthreads
	uint groupIndex : SV_GroupIndex,
	// flattened/linearized SV_GroupThreadID. 
	// groupIndex specifies the index within the group (0 to 63)
	uint3 id : SV_DispatchThreadID)
	// = SV_GroupID * numthreads + SV_GroupThreadID
	// id.x specifies the row in the input texture image
{
	float4 d_dim;
	Destination.GetDimensions(d_dim.z, d_dim.w);

	d_dim.xy = 1 / d_dim.zw;

	float beam_num = id.x;

	float leftZone = step(beam_num, BeamCount_left);
	float midZone = step(BeamCount_left, beam_num)*step(beam_num, (BeamCount_left + BeamCount_mid));
	float rightZone = step((BeamCount_left + BeamCount_mid), beam_num);

	float B_density = (rightZone + leftZone)*OutBeamDensity + midZone * InBeamDensity;
	B_density = FlexModeEnabled * B_density + (1 - FlexModeEnabled)*(DefaultBeamDensity);

	float startUV = midZone * LeftUVBorder + rightZone * RightUVBorder;

	float flexX = ( leftZone * (beam_num-0.5)+midZone * (beam_num - BeamCount_left) + rightZone * (beam_num - (BeamCount_left + BeamCount_mid-0.5)))/512.;
	flexX = ((flexX)*B_density + startUV);

	float coordX = (flexX *FlexModeEnabled + (1 - FlexModeEnabled)*id.x / BeamCount);
	//coordX = id.x / BeamCount;
	float2 uv = float2(coordX, float(BeamBuffer[id.x].x) / 512.);

	float2 dx = float2(1, 0);
	float2 dy = float2(0, 1);
	Destination[uv*d_dim.zw] = BeamBuffer[beam_num].y;
	for (int i = 1; i < 2; i++) {

		Destination[uv*d_dim.zw + i * dx] = 1;// BeamBuffer[id.x].y;
		Destination[uv*d_dim.zw - i * dx] = 1;// BeamBuffer[id.x].y;
		Destination[uv*d_dim.zw + i * dy] = 1;// BeamBuffer[id.x].y;
		Destination[uv*d_dim.zw - i * dy] = 1;// BeamBuffer[id.x].y;
	}
}*/



float3 DetectColor;
[numthreads(64, 1, 1)]
void RenderDetect(uint3 groupID : SV_GroupID,
	// 3D ID of thread group; range depends on Dispatch call
	uint3 groupThreadID : SV_GroupThreadID,
	// 3D ID of thread in a thread group; range depends on numthreads
	uint groupIndex : SV_GroupIndex,
	// flattened/linearized SV_GroupThreadID. 
	// groupIndex specifies the index within the group (0 to 63)
	uint3 id : SV_DispatchThreadID)
	// = SV_GroupID * numthreads + SV_GroupThreadID
	// id.x specifies the row in the input texture image
{
	float4 d_dim;
	Destination.GetDimensions(d_dim.z, d_dim.w);

	d_dim.xy = 1 / d_dim.zw;

	float beam_num = id.x % BeamCount;

	float leftZone = step(beam_num, BeamCount_left);
	float midZone = step(BeamCount_left, beam_num)*step(beam_num, (BeamCount_left + BeamCount_mid));
	float rightZone = step((BeamCount_left + BeamCount_mid), beam_num);

	float B_density = (rightZone + leftZone)*OutBeamDensity + midZone * InBeamDensity;
	B_density = FlexModeEnabled * B_density + (1 - FlexModeEnabled)*(DefaultBeamDensity);

	float startUV = midZone * LeftUVBorder + rightZone * RightUVBorder;

	float flexX = (leftZone * (beam_num - 0.5) + midZone * (beam_num - BeamCount_left) + rightZone * (beam_num - (BeamCount_left + BeamCount_mid - 0.5))) / Resolution;
	flexX = ((flexX)*B_density + startUV);

	float coordX = (flexX *FlexModeEnabled + (1 - FlexModeEnabled)*id.x / BeamCount);
	//coordX = id.x / BeamCount;
	float2 uv = float2(abs(step(MirrorImage,0)-coordX), float(BeamBuffer[id.x].x) / 512.);
	float a = clamp(uv.x,0,1) *HorisontalFOV;
	a -= -(Rotation - HorisontalFOV / 2) % 360;
	a = (360 + a) % 360;
	//a = 90;
	a *= 0.0174533;


	float r = uv.y / 2.;
	uv = float2(r*sin(a), r*cos(a));
	uv *= d_dim.xy;
	float minRes = min(d_dim.z, d_dim.w);
	uv *= minRes;
	uv *= Scale_factor;
	uv += 0.5;
	uv += Offset;

	//Destination[uv*d_dim.ww] = 1;
	float2 dx = float2(1, 0);
	float2 dy = float2(0, 1);
	for (int i = 0; i < 2; i++) {

		Destination[uv*d_dim.zw] = float4(DetectColor, 1);
		Destination[uv*d_dim.zw + i * dx] = float4(DetectColor, 1);// BeamBuffer[id.x].y;
		Destination[uv*d_dim.zw - i * dx] = float4(DetectColor, 1);// BeamBuffer[id.x].y;
		Destination[uv*d_dim.zw + i * dy] = float4(DetectColor, 1);// BeamBuffer[id.x].y;
		Destination[uv*d_dim.zw - i * dy] = float4(DetectColor, 1);// BeamBuffer[id.x].y;
	}

}

int Wedge_MemoryAmount;
int PingNumber;
float2 SwathShift;
int SwathSpacing;

float SWS_x, SWS_y;


float ZeroLevel, UpperLevel;
float DetectModeEnabled;
float Range;

float4 History_Colors[8];
int History_ColorsCount;

float3 LerpHistoryPixColors(float x) {
	
	float sT = clamp(x, 0, 1) * (float)(History_ColorsCount - 1);
	float3 oldColor = History_Colors[floor(sT)].rgb;
	float3 newColor = History_Colors[ceil(sT)].rgb;
	float newT = sT - floor(sT);

	float3 color = lerp(oldColor, newColor, newT);
	return color;
}

[numthreads(64, 1, 1)]
void DrawWedgeHistory(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	float4 d_dim;
	Destination.GetDimensions(d_dim.z, d_dim.w);

	d_dim.xy = 1 / d_dim.zw;

	float beam_num = id.x % BeamCount;

	float leftZone = step(beam_num, BeamCount_left);
	float midZone = step(BeamCount_left, beam_num)*step(beam_num, (BeamCount_left + BeamCount_mid));
	float rightZone = step((BeamCount_left + BeamCount_mid), beam_num);

	float B_density = (rightZone + leftZone)*OutBeamDensity + midZone * InBeamDensity;
	B_density = FlexModeEnabled * B_density + (1 - FlexModeEnabled)*(DefaultBeamDensity);

	float startUV = midZone * LeftUVBorder + rightZone * RightUVBorder;

	float flexX = (leftZone * (beam_num - 0.5) + midZone * (beam_num - BeamCount_left) + rightZone * (beam_num - (BeamCount_left + BeamCount_mid - 0.5))) / Resolution;
	flexX = ((flexX)*B_density + startUV);

	float coordX = (flexX *FlexModeEnabled + (1 - FlexModeEnabled)*beam_num / BeamCount);
	//coordX = id.x / BeamCount;
	float2 uv = float2(abs(step(MirrorImage,0) - coordX), float(BeamBuffer[id.x].x) / 512.);
	float a = clamp(uv.x,0,1) *HorisontalFOV;
	a -= -(Rotation  - HorisontalFOV / 2) % 360;
	a = (360 + a) % 360;
	//a = 90;
	a *= 0.0174533;
	
	
	float r = uv.y/2;
	uv = float2(r*sin(a), r*cos(a));
	uv *= d_dim.xy;
	float minRes = min(d_dim.z, d_dim.w);
	uv *= minRes;
	uv *= Scale_factor;
	uv += 0.5;
	uv += Offset;

	float beam_pos = (id.x / BeamCount);
	int j = floor(mod((PingNumber - clamp(beam_pos,0,BeamCount)) , Wedge_MemoryAmount));
	uv = uv + float2(SWS_x,SWS_y)*d_dim.xy*SwathSpacing*j;

	//Destination[uv*d_dim.ww] = 1;
	float2 dx = float2(1, 0);
	float2 dy = float2(0, 1);
	//
	float c = float(BeamBuffer[id.x].y)/10000.;
	
	
	float Ycoord = remap(0, 1, ZeroLevel, UpperLevel, float(BeamBuffer[id.x].z)/10000.);

	float3 BotCol = float3(0.1, 0.8, 0.1);
	float3 MidCol = float3(1, 1, 0);
	float3 UpCol = float3(1, 0, 0);
	// sample the texture
	float middle = 0.5;
	float factor = Ycoord;
	float3 depthCol = lerp(BotCol, MidCol, clamp((factor) / middle, 0, 1))*step(factor, middle) + lerp(MidCol, UpCol, clamp((factor - middle) / middle, 0, 1))*step(middle, factor);
	depthCol = LerpHistoryPixColors(factor);
	
	float4 col = float4(c*depthCol+(1- c)*Source[uv*d_dim.zw].rgb,1);
	
	for (int i = 1; i < 2; i++) {
		Destination[uv*d_dim.zw] = col;
		Destination[uv*d_dim.zw + i * dx] =  float4(col);
		Destination[uv*d_dim.zw - i * dx] = float4(col);
		Destination[uv*d_dim.zw + i * dy] = float4(col);
		Destination[uv*d_dim.zw - i * dy] = float4(col);
	}


}
