#pragma kernel MapDepthToQuadSonar
#pragma kernel MapNoiseToQuadSonar


#pragma kernel ClearBuffer

#include "../SonarsDistributionBase.cginc"
Texture2D<float4> Source;
RWTexture2D<float4> Destination;
RWStructuredBuffer<float> DistanceBuffer;


Texture2D<float4> Noise1;
Texture2D<float4> Noise2;
float Zoom_angle1, Zoom_angle2;
float Gain, TVG, NoiseWideness, NoisePatternScroll, BlindZoneRadius, HorisontalFOV,VerticalFOV;
float4 Noise12_Scale_Bias;
float Range;
float4 WorldPosRot;
float TopNoiseTreshold;
float BottomNoiseTreshold;



void BilinearColorPixels(float2 uv, float color,float2 dim,float max,float gain)
{
	uv.y += 0.5;
	float2 y_min_max = float2(floor(uv.y) - 0.5, floor(uv.y) + 0.5);

	float uv_frac = 1-frac(uv.y);

	float2 uv1 = float2(uv.x, y_min_max.x);
	float2 uv2 = float2(uv.x, y_min_max.y);
	if (DistanceBuffer[uv1.x + uv1.y*dim.x] > max ) return;
	DistanceBuffer[uv1.x + uv1.y*dim.x] += uv_frac*color;
	DistanceBuffer[uv2.x + uv2.y*dim.x] += uv_frac*color;
	
	float val1 = clamp(DistanceBuffer[uv1.x + uv1.y*dim.x], 0, gain*5);
	val1 = DistanceBuffer[uv1.x + uv1.y*dim.x];
	float val2 = clamp(DistanceBuffer[uv2.x + uv2.y*dim.x], 0, gain*5);
	val2 = DistanceBuffer[uv2.x + uv2.y*dim.x];
	//val1 =remap(0,max,0,gain*5, val1);
	//val2 =remap(0,max,0,gain*5,val2);
	//Destination[uv1] = DistanceBuffer[uv1.x + uv1.y*dim.x];
	//Destination[uv2] = DistanceBuffer[uv2.x + uv2.y*dim.x];
	Destination[uv1] = val1 +val1 * 0.2* (2 * rand(uv1) - 1);
	Destination[uv2] = val2 +val1 * 0.2* (2 * rand(uv2) - 1);
}

[numthreads(16, 16, 1)]
void MapDepthToQuadSonar(uint2 id : SV_DispatchThreadID)
{
	float4 s_dim;
	s_dim = GetDimensionsFrom(Source);


	float4 d_dim;
	Destination.GetDimensions(d_dim.z, d_dim.w);
	d_dim.xy = float2(1 / d_dim.z, 1 / d_dim.w);
	float2 uvstart = float2(id.x, id.y);

	float4 DRWB = Source[id.xy];

	float ran = rand(id.xy);
	float delta01Obj = ran;
	float x = id.x*s_dim.x;
	
	float2 coords = float2(id.xy*s_dim.xy);
	coords.x = remap(Zoom_angle1, Zoom_angle2, 0, 1, coords.x);
	coords = PaniniProjectionScreenPosition(coords * 2 - 1, HorisontalFOV)+0.5;
	//coords.y += 0.5;
	coords.x = remap(0, 1, PaniniProjectionScreenPosition(2*Zoom_angle1-1, HorisontalFOV).x+0.5, PaniniProjectionScreenPosition(2 * Zoom_angle2 - 1, HorisontalFOV).x + 0.5, coords.x );
	float pixel_angle = (coords.x);
	//pixel_angle = (pos.x);
	//pixel_angle = x;
	float wideness = lerp(0, 1, DRWB.z) / Range;

	//wideness = 0.001;
	float internalWideness = 0.001;
	//internalWideness = 0;
	float radius = DRWB.x *(1 - wideness * (delta01Obj)+internalWideness * (2*delta01Obj-1));// +0.005*rA;

	float2 coord = float2(pixel_angle, radius)*d_dim.zw;
	float g = 0.1 + Gain * (1 + remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440))*remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440)));

	GroupMemoryBarrier();
	GroupMemoryBarrierWithGroupSync();
	float2 dx = float2(1, 0);
	float2 dy = float2(0,1);

	float t = (1 - DRWB.x);

	float oRefl = DRWB.y;
	float reflectivity = clamp(oRefl*lerp(0., 1, t) + lerp(0, TVG, DRWB.x*DRWB.x) / 10, 0, oRefl);
	
	float blindZone = clamp(remap(BottomNoiseTreshold, TopNoiseTreshold, 12, 20, VerticalFOV) / Range, 0, 1);
	float c = remap(1, 0, blindZone - 0.05, blindZone + 0.05, clamp(radius, blindZone - 0.05, blindZone + 0.05));
	reflectivity *= c;
	g *= reflectivity;
	BilinearColorPixels(coord, 5* g, d_dim.zw, reflectivity, Gain);
	BilinearColorPixels(coord + dy, g, d_dim.zw, reflectivity, Gain);
	BilinearColorPixels(coord - dy, g, d_dim.zw, reflectivity, Gain);
}


[numthreads(16, 16, 1)]
void MapNoiseToQuadSonar(uint2 id : SV_DispatchThreadID)
// = GroupID * numthreads + GroupThreadID
{
	float4 s_dim;
	s_dim = GetDimensionsFrom(Source);
	float4 n_dim;
	n_dim = GetDimensionsFrom(Noise2);
	float4 n_main_dim;
	n_main_dim = GetDimensionsFrom(Noise1);
	float2 d_dim;
	Destination.GetDimensions(d_dim.x, d_dim.y);

	float ran = rand(id.xy);

	//float2 pos = PaniniProjectionScreenPosition(id.xy*s_dim.xy * 2 - 1);
	//float pixel_angle = (pos.x + 0.5);


	float2 coords = float2(id.xy*s_dim.xy);
	coords.x = remap(Zoom_angle1, Zoom_angle2, 0, 1, coords.x);
	coords = PaniniProjectionScreenPosition(coords * 2 - 1, HorisontalFOV) + 0.5;
	coords.x = remap(0, 1, PaniniProjectionScreenPosition(2 * Zoom_angle1 - 1, HorisontalFOV).x + 0.5, PaniniProjectionScreenPosition(2 * Zoom_angle2 - 1, HorisontalFOV).x + 0.5, coords.x);
	float pixel_angle = (coords.x);
	float sc = lerp(1, 2, 1- (Range-2) / 300);
	float2 n1_uv_sample = GetNoiseUVrelativeToWorld(float2(coords.x,id.y*s_dim.y), WorldPosRot, 1, NoisePatternScroll);
	float2 n2_uv_sample = GetNoiseUVrelativeToWorld(float2(coords.x, id.y*s_dim.y), float4(-1, 1, 1, 1)*WorldPosRot + float4(10, 5, 15, 20), 1, NoisePatternScroll);
	
	

	//float n1_radius = getRandomBeizerEase(Noise1[n1_uv_sample].r, Bezier_Params.x, Bezier_Params.y);
	//float n2_radius = getRandomBeizerEase(Noise2[n2_uv_sample].r, Bezier_Params.x, Bezier_Params.y);
	
	//n2_radius = lerp(0, 1.5, n2_radius);
	//n2_radius *= (1 + 0.1*NoiseWideness / 10 * (2 * ran - 1));



	float n1_radius, n2_radius;

	n1_radius = smoothNoise((n1_uv_sample*Noise12_Scale_Bias.x));

	n2_radius = warpedNoise((float2(frac(n2_uv_sample + 0.5))*Noise12_Scale_Bias.y), WorldPosRot);
	n2_radius = remap(0, 1, 0.2, 0.8, n2_radius);
	n1_radius *= (1 + NoiseWideness/10  *(2 * ran - 1)*0.1);
	n1_radius = bias(n1_radius, Noise12_Scale_Bias.z);
	n2_radius = bias(n2_radius, Noise12_Scale_Bias.w);

	float2 n1_uv = float2(pixel_angle, n1_radius)*d_dim;
	float2 n2_uv = float2(pixel_angle, n2_radius)*d_dim;

	float4 DRWB = Source[id.xy];

	float t = (1 - DRWB.x);
	t = clamp(t, 0.5, 1);
	t = remap(0, 0.6, 0.5, 1, t);

	float wideness = lerp(0, 10*DRWB.z, t*t)*step(DRWB.y*(1-DRWB.x),0.4);
	float internalWideness = 0.01;
	float radius_noised = DRWB.x *(1 - wideness * (ran) +internalWideness * (ran ));

	float2 coord_noised = float2(pixel_angle, radius_noised)*d_dim;

	coord_noised.x += 4*(2*ran - 1)*step(DRWB.y, 0.4);

	float2 dx = float2(1, 0);
	float2 dy = float2(0, 1);

	t = (1 - DRWB.x);
	float oRefl = 0.15;

	float reflectivity = clamp(oRefl*lerp(0, 1, t) + lerp(0, TVG, DRWB.x*DRWB.x) / 10, 0, oRefl);
	
	float blindZone = clamp(remap(BottomNoiseTreshold, TopNoiseTreshold, 10, 20, clamp(VerticalFOV,10,20)) / Range, 0, 1);
	float c = remap(rand(id.xy), 0, blindZone - 0.05, blindZone + 0.05, clamp(radius_noised, blindZone - 0.05, blindZone + 0.05));
	reflectivity *= c;

	float g = 0.2 + Gain * (1 + remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440))*remap(0, 1, 720, 1440, clamp(d_dim.x, 720, 1440)));

	//BilinearColorPixels(coord_noised,  5*Gain*Gain, d_dim, reflectivity, Gain);
	t = 1-n1_radius;
	reflectivity = lerp(oRefl*t + lerp(0, TVG, n1_radius*n1_radius) / 10, 1, g*g);
	float g1 =g* reflectivity;
	//Noise
	BilinearColorPixels(n1_uv, g1*g1, d_dim, reflectivity, Gain);
	
	t = 1 - n2_radius;
	reflectivity = lerp(oRefl*t + lerp(0, TVG, n2_radius*n2_radius) / 10, 1, g*g);
	g1 = g*reflectivity;
	BilinearColorPixels(n2_uv, g1*g1, d_dim, reflectivity, Gain);
}


[numthreads(1024, 1, 1)]
void ClearBuffer(uint3 groupID : SV_GroupID,
	uint3 groupThreadID : SV_GroupThreadID,
	uint groupIndex : SV_GroupIndex,
	uint3 id : SV_DispatchThreadID)
{
	DistanceBuffer[id.x] = 0;
}